'''
Inference script for AMF / NMF classification on stacked histopathology crop‑outs.

* Model : 2D.ConvNeXtBase
* Weights: 
* Input  : /input/images/stacked-histopathology-roi-cropouts/*.tif(f) (multi‑page TIFF generated by Pillow)
* Output : /output/multiple-mitotic-figure-classification.json

Each TIFF page is scored independently.  The JSON contains one object per
page with the probability of atypical mitosis, regardless of the winning
class.
'''
import os
import cv2
import json
import torchstain
import numpy as np
import pandas as pd
from glob import glob
from typing import List
from pathlib import Path
from PIL import Image, ImageSequence

from aucmedi import *
from aucmedi.ensemble import Bagging
from aucmedi.neural_network.model import NeuralNetwork
from aucmedi.data_processing.io_loader import cache_loader
from aucmedi.data_processing.subfunctions.sf_base import Subfunction_Base

# Paths & constants
INPUT_PATH = Path('/input')
JSON_PATH = INPUT_PATH / 'inputs.json'
IMAGES_PATH = INPUT_PATH / 'images/stacked-histopathology-roi-cropouts'

RESOURCES_PATH = Path('/opt/app/resources')
TARGET_PATH = RESOURCES_PATH / 'target.png'  # Stain normalization target
OUTPUT_PATH = Path('/output')
MODEL_PATH = Path('/opt/app/model')
MODEL_NAME = '2D.ConvNeXtBase'

CLASS_NAMES = {0: 'atypical', 1: 'normal'}
THRESHOLD = 0.5  # probability threshold for classifying *normal*

# stain normalisation subfunction
class stain_norm(Subfunction_Base):
    def __init__(self, target_path):
        self.normalizer = torchstain.normalizers.ReinhardNormalizer(backend='numpy', method=None)
        target_img = cv2.cvtColor(cv2.imread(target_path), cv2.COLOR_BGR2RGB)
        self.normalizer.fit(target_img)

    def transform(self, image):
        return self.normalizer.normalize(I=image)

# Helper functions
def load_image_stack(dir_path: Path) -> List[np.ndarray]:
    tiffs = glob(str(dir_path / "*.tif")) + glob(str(dir_path / "*.tiff"))
    if not tiffs:
        raise FileNotFoundError(f"No TIFF files found in {dir_path}")
    with Image.open(tiffs[0]) as tif:
        return [np.array(p.convert("RGB")) for p in ImageSequence.Iterator(tif)]
    
def get_interface_key() -> tuple[str, ...]:
    with open(JSON_PATH, 'r') as f:
        inputs = json.load(f)
    return tuple(sorted(sv['interface']['slug'] for sv in inputs))

def write_json(path: Path, obj):
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, 'w') as f:
        json.dump(obj, f, indent=4)

# Inference handler
def interf0_handler() -> int:
    # Load TIFF stack
    slices = load_image_stack(IMAGES_PATH)

    cache = {}
    i = 0
    for sl in slices:
        cache[i] = sl
        i += 1
    sample_list = list(cache.keys())

    # Prepare model
    model = NeuralNetwork(n_labels=2, channels=3, architecture=MODEL_NAME)
    el = Bagging(model, k_fold=3)  # Ensemble with 3-fold bagging
    el.load(MODEL_PATH)

    # define test data generator and make predictions
    test_generator = DataGenerator(samples=sample_list,
                                   path_imagedir=None,
                                   labels=None,
                                   data_aug=None,
                                   subfunctions=[stain_norm(target_path=TARGET_PATH)],
                                   resize=model.meta_input,
                                   standardize_mode=model.meta_standardize,
                                   image_format=None,
                                   batch_size=16,
                                   grayscale=False,
                                   prepare_images=True,
                                   sample_weights=None,
                                   seed=1234,
                                   workers=1,
                                   loader=cache_loader,
                                   cache=cache)
    # Run inference
    preds = el.predict(test_generator, aggregate='mean')

    df_pd = pd.DataFrame(data=preds, columns=['pd_' + i for i in CLASS_NAMES.values()])
    df_merged = pd.concat([df_pd], axis=1, sort=False)
    predictions = []

    for row in df_merged.itertuples():
        p_normal = row.pd_normal  # Probability of normal class
        p_atyp   = row.pd_atypical # Probability of atypical class
        cls_idx  = 1 if p_normal >= THRESHOLD else 0
        predictions.append({'class': CLASS_NAMES[cls_idx], 'confidence': round(p_atyp, 4)})

    # Persist
    write_json(OUTPUT_PATH / 'multiple-mitotic-figure-classification.json', predictions)
    return 0

# Entrypoint
def run() -> int:
    handlers = {('stacked-histopathology-roi-cropouts',): interf0_handler}
    key = get_interface_key()
    if key not in handlers:
        raise KeyError(f'Unsupported interface combination: {key}')
    return handlers[key]()


if __name__ == '__main__':
    raise SystemExit(run())
